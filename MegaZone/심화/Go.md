# GO Lang

---
## 목차
1. [Go 언어](#go-언어)
2. [기본 데이터 타입](#기본-데이터-타입)
3. [복합 타입](#복합-타입)
4. [블록, 섀도, 제어 구조](#블록-섀도-제어-구조)
5. [함수](#함수)
6. [포인터](#포인터)
7. [타입, 메서드, 인터페이스](#타입-메서드-인터페이스)
8. [Go의 동시성](#go의-동시성)

## Go 언어

- 컴파일 언어
- 코드 작성이 효율적인 언어, 구문이 단순하고 컴파일러 빨라야함
- scale up vs scale out 
- Go 작업공간 - GOPATH 환경 변수 set GOPATH
- 작업 공간의 기본 디렉토리 : GOPATH=$Home/go, GOPATH=%USERPROFILE%\go
- Go는 다른 언어와 달리 자신의 코드 저장소를 공유하여 패키지를 직접 다운받고 설치 가능

### GO 명령어

- go run [go 파일... | go 패키지] - 작은 프로그램 테스트, Go를 스크립트 언어처럼 사용
- go build [go 파일... | go 패키지] - 바이너리(실행파일) 생성, 최종 베포본 파일 만들기
  
```go
$ go build hello.go
$ go build -o hello_world.exe hello.go
$ go install github.com/rakyll/hey@latest
```
### Code Formatting

- go fmt 
  - 들여쓰기 공백 수정
  - 구조체 항목 정렬
  - 연산자 주변 적절한 공백 사용 체크
- goimports
  - import 문 정리
  - 알파벳 순 정렬
  - 사용되지 않은 import 삭제
  - import 추측 
- 세미클론 삽입 규칙 
  - Go 컴파일러가 자동으로 문장 끝에 세미콜론을 붙여줌
  - 식별자, 기본 리터럴, 토큰들(break, continue, fallthrough, return, '++', '--', ')', '}')

### 개발 도구

- VS Code
- GoLand
- Go Playground

---

## 기본 데이터 타입

- 불리언
- 숫자
  - 정수 - 주로 int 사용, 경우에 따라 byte
  - 실수 
  - 복소수
- 문자열
- 별칭(Alias) : byte(uint8), rune(int32)
- 제로 값 : 선언되었으나 값이 할당되지 않은 변수에 기본 값 제로(0) 할당

### 리터럴

- 코드에 작성하는 값 그 자체 
- 정수 리터럴
    - 10진수, 8진수, 16진수, 2진수 => 접두사 이용(없음, 0o, 0x, 0b)
    - 밑줄 (underscore) : 정수 리터럴 사이에 1_234
- 부동 소수점 리터럴
  - 점(.)
  - e(E) 지수 표현
  - 밑줄 가능
- 룬 리터럴
  - 작은 따옴표
  - 단일 유니코드 문자, 8비트 8진 숫자, 8비트 16진수 숫자, 16비트 16진수 숫자, 32비트 유니코드
  - 이스케이프 시퀀스: '\n', '\t', ... 
- 문자 리터럴
  - 두가지 방법
        1. 해석된 문자열 리터럴 : 큰 따옴표 사용
            - 이스케이프 룬이 처리가 됨
        2. raw 문자열 : 역따옴표(백틱) 사용
```go
package main

import "fmt"

func main() {
	fmt.Println("Hello world!")
	fmt.Println("Greetings and\n\"Salutations\"")
}
```
- 다른 타입으로 선언된 두 정수는 연산 불가능
  - 부동 소수점 변수에 정수 리터럴 사용 가능
  - 정수 변수에 부동소수점 리터럴 사용 가능

- Go 언어는 실용적 언어 => `리터럴에는 타입 X `

### 숫자 타입

- 정수 타입
  - 특수한 경우 아니면 int 사용
  - int 기본 타입
- 특수 정수 타입들
  - byte : uint8 보다 선호
  - int : 플랫폼에 따라서 int32, int 64
  - uint : 플랫폼에 따라서 uint32, uint 64 
  - rune : int32이지만 용도 다름
  - uintptr : 포인터
- 정수 연산자
  - 산술연산자의 결과는 정수
  - 복합 대입 연산자도 지원
  - 비교연산자
  - 비트연산자
  - 논리연산자
  - shift연산자
- 부동소수 타입
  - float32, float64(기본 타입) 
  - %(나머지 연산) 에 대해서는 정의되어 있지 않음
  - 부동소수 변수끼리 ==, != 비교는 가능하나 사용하지 말 것 

### 문자열과 룬

- 문자열
  - 제로 값: 비어있는 문자열
  - 비교연산자 가능
  - 연결연산자(+)
  - 불변(immutable)
  - 큰 따옴표

- 룬
  - 단일 코드 포인트
  - 작은 따옴표
  - int32의 별칭

### 명시적 타입 변환

- Explict(명시적) vs Implicit(암시적, 암묵적)
  - Manual vs Automatic
- 자동 타입 변환
  - 편리
  - 변환 규칙이 복잡, 예기치 못한 결과 초래 가능
- `Go는 자동 타입 변환 불허` => 의도의 명확성 및 가독성 중시 때문 , 명시적으로 타입 변환
- 다른 Go 타입을 불리언으로 취급 X
- 조건식은 반드시 비교식으로 작성 
```go
package main

import "fmt"

func main() {
	var x int16 = 10
	var y int8 = 20
	fmt.Println(x + int16(y))
}

```

### var vs :=

- 변수 선언 스타일에 따른 의도가 존재
- var
  - var 변수 타입 = 값(표현식), 타입 또는 값 생략 가능
  - 값의 타입이 예상 가능하면 타입 생략 가능
  - 값의 생략하면 타입의 제로 값
  - 같은 타입의 여러 변수 또는 다른 타입의 여러 변수 동시 선언 가능
  - 여러 변수의 제로 값 동시 선언 가능
```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var x rune
	fmt.Println(x, reflect.TypeOf(x))
}
```
- 다양한 변수를 한 번에 선언
  - 선언리스트를 괄호로 묶음
- := 짧은 선언
  - var 키워드(x)
  - 타입(x)
  - 함수 밖에서는 사용 불가 = package 레벨에서 사용 불가 

### const 사용

- 상수 변수
- 한 번 대입한 값을 변경할 수 없음
- 컴파일 시 값이 결정되어야 함, 즉 변수를 대입 X
- 리터럴에 이름을 부여하는 방법

### 타입 지정 상수와 타입 미지정 상수

- 프로그래밍 의도
- 타입 미지정 상수는 리터럴과 같은 취급
- 타입 지정 상수는 해당 타입 변수에만 할당

### 사용하지 않는 변수 

- 지역 변수는 반드시 사용
- 사용되지 않는 상수도 허용

### 변수와 상수 이름

- Go는 유니코드 문자를 식별자로 허용 / 권장 X
- Go는 관용적으로 스네이크 표기법 사용 X
  - 낙타 표기법
  - 파스칼 표기법
- 상수 : 모든 문자를 대문자, 각 단어는 밑줄로 구분
  - 패키지에 포함된 요소를 외부에 노출시킬지 여부를 식별자의 첫글자가 대소문자 여부로 결정
- 함수 내에서는 짧은 변수 이름 선호
  - 변수의 의미보다 간결성을 선호 

---

## 복합 타입

### 배열(array)

- 같은 타입의 여러 데이터를 담음
- 시퀀스 타입(순서 중요)
- Go에서는 선호 X (특별한 경우에만 사용)
- 선언시 크기 지정, 크기 변경 X
- 배열간 비교 가능(==, !=)
- 배열 인덱스는 범위를 벗어나서는 안되고 음수도 불가
- 선언 방법
   1. 제로 값으로 선언: 배열의 크기와 배열 내 요소 타입 지정
   2. 배열 초깃값 지정: 배열 리터럴 사용
   3. 희소 배열: 대부분의 요소가 0인 배열
   4. 배열 크기 지정 X: 배열 리터럴 필요
   5. 다차원 배열: [ ]의 개수가 차원 수 
- 배열 요소 접근
  - [ ] 사용
- 배열 길이
  - len() 함수
- Go에서 배열을 잘 사용하지 않는 이유
  - 배열의 크기가 배열의 타입을 결정하는데 사용됨
  - 원소의 타입이 같은 배열이라도 크기가 다르면 다른 타입
  - 크기가 다르면 타입 변환도 불가능

### 슬라이스(Slice)

- 시퀀스를 저장하는 자료구조(순서 중요)
- 슬라이스의 크기는 타입의 일부가 아니다 (배열과의 큰 차이점)
- 슬라이스 간 비교는 불가(배열과 다른 점)
- nil과는 비교 가능
- 슬라이스 길이
  - len() 함수
- 선언 방법
  1. 슬라이스 초깃값 지정: 슬라이스 리터럴
  2. 희소 슬라이스
  3. 다차원 슬라이스
  4. 제로 슬라이스: 슬라이스 리터럴 없이 선언만 하는 것
     - 슬라이스 제로 값은 `nil`
     - nil : 값의 부재 상태
     - nil은 타입이 없음
  5. 비어있는 슬라이스: 슬라이스 리터럴에 초깃값이 없는 것
- append
  - 슬라이스에 새로운 요소 추가
  - append의 결과를 할당하지 않으면 컴파일 에러
- 수용력(capacity)
  - 예약된(미리 준비된) 연속적인(consecutive) 메모리 공간의 크기 
  - 수용력 >= 길이
  - 요소가 추가되면 길이는 커지고 결국 수용력과 같아짐
  - 길이와 수용력이 같은 상태에서 요소가 추가되면 Go 런타임이 더 큰 수용력이 가지는 `새로운` 슬라이스를 할당, 슬라이스의 값들은 새 슬라이스에 복사
  - 추가된 값은 새 슬라이스에 append, 새 슬라이드 반환
- make()
  - 슬라이스에 저장될 요소 개수를 미리 알 수 있다면 make() 사용 효율적인 슬라이스 작업
  - make로 생성한 슬라이스에 append를 사용할 땐 주의
- 슬라이스 생성
  - 제로 슬라이스
  - 슬라이스 리터럴
  - make()

### 슬라이스의 슬라이싱
- 슬라이스 연산자(:)
- 슬라이스 연산자를 사용하면 복사본을 만들지 않고 메모리를 공유
- 슬라이싱과 append를 함께 사용하면 혼란이 가중됨
- 하위 슬라이스의 수용력
  - 원본 슬라이싱의 수용력 - 하위 슬라이스 시작 오프셋
- 하위 슬라이스와 append를 아무 생각 없이 사용하면 혼란이 가중
  - 의도치 않은 값 변경이 발생
  - 완전한 슬라이스 표현식(full slice expression)
  - 하위 슬라이스에 얼마나 많은 메모리를 공유할 것인지를 지정
  - 슬라이스 연산 때 콜론을 한번 더 사용, 세번째 인자에 원본
- 슬라이스에서 하위 슬라이스의 마지막 요소 위치 지정 
  - 슬라이스 연산의 세 번째 인자의 값을 두 번째 인자의 값과 같도록 설정

### 배열을 슬라이스로 변환

- 배열에 슬라이스 연산 적용
- 메모리 공유 문제 존재

### copy

- copy() 내장 함수
- copy의 첫 번째 인자는 슬라이스

### 문자열과 룬,바이트

- 문자열은 룬으로 이루어진 것 X, 바이트의 시퀀스
- 문자열의 길이는 바이트 수
- 문자열에 슬라이스 연산 사용 가능
  - 문자열은 수정불가(immutable)이므로 슬라이스의 메모리 공유 문제 X
  - 유니코드로 구성되므로 슬라이스를 했을 때 문자가 깨짐
- 문자열은 바이트 슬라이스 또는 룬 슬라이스로 변환 가능 

### 맵

- 순서 없는 데이터 처리 유용
- (Key, Value) pair
  - var 변수명 map\[키타입\]값타입
- 키 : 비교 가능한 타입만 가능(맵, 슬라이스 X)
- 값 : 어느 타입도 가능 
- 생성
  1. nil 맵(제로 값 할당) : map의 제로 값은 nil
     1. nil 맵은 길이 0
     2. nil 맵이 값을 읽으면 맵 값이 되는 타입의 제로 값
     3. nil 맵에 값을 쓰려고 하면 패닉(에러) 발생
  2. 맵 리터럴 : 비어 있는 맵 생성
     1. nil 맵과 다르다
     2. 길이는 0
     3. 비어 있는 맵 리터럴이 할당된 맵을 읽고 쓸 수 있음
  3. 값이 있는 맵 리터럴
     1. 키와 값을 콜론으로 구분
     2. 마지막 요소(키,값)의 끝에 콤마를 붙임
  4. make() 함수로 생성
     - 맵의 요소 개수를 안다면
     - 길이는 0 (make()로 슬라이스 만드는 것과 다름)
     - 초기 지정 개수 이상으로 커짐
     - 맵의 제로 값은 nil
     - 맵은 비교 불가능, nil과 같은지 다른지 비교 가능
- 맵 읽고 쓰기
  - := 연산자 사용 불가
  - 아직 설정되지 않은 키에 할당된 값을 읽으면 값 타입의 제로 값 반환
- 콤마 OK 관용구 (idiom)
  - 맵의 키에 대응되는 값이 없어도 제로 값이 리턴
  - 맵에 키가 존재하는지 확인할 필요가 있을 때 주로 사용하는 패턴
    - 맵에 키가 없어서 제로 값이 반환되는 건지
    - 실제로 키가 있는데 해당 값이 제로인건지 확인
- 맵 삭제
  - delete() 내장 함수 사용
  - 키가 존재하지 않거나 nil 맵인 경우 아무것도 X
  - delete() 반환값 X
- 맵을 셋(집합)으로 이용
  - 집합(셋)
    - Uniqueness, 시퀀스 X
  - Go 집합형 없음, 맵을 통해 간접적으로 지원
    - 집합의 원소로 쓰고 싶은 타입을 맵의 키 타입으로
    - 맵의 값을 불리언으로 설정 

### 구조체

- 여러 데이터 타입을 묶어서 다루고 싶을 때 사용
- 구조체는 사용자 정의 타입
- 구조체 항목들은 콤마로 구분 X
- 구조체는 어떤 블록 레벨에서도 정의 가능
- 구조체 정의 -> 구조체를 타입으로 하는 변수 선언
- 구조체의 제로 값
  - 구조체를 구성하는 항목들의 제로 값
- 구조체 리터럴
  1. 방법 1
    - 구조체 항목 값은 구조체 정의한 순서대로 나열 
    - 구조체 항목 값은 콤마로 구분하고 마지막 항목에서 콤마를 붙여야 함
  2. 방법 2
    - Map 리터럴과 유사
    - 순서 무관
    - 생략할 경우 제로 값으로 설정
- 제로 구조체와 비어 있는 구조체는 차이점 X 

### 익명 구조체

- 한 번만 사용할 구조체
- type 생략 -> 구조체 이름 없음
- 구조체 변수만 존재
- 주요 용도
  - 마샬링, 언마샬링
  - 테스트 작성

### 구조체 비교와 변환
- 구조체 비교는 항목에 따라 다름
- 두 개의 구조체가 같은 이름, 순서, 타입으로 구성되어 있으면 구조체 간에 타입 변환 가능
```go
package main

import "fmt"

func main() {
	type firstPerson struct {
		name string
		age  int
	}

	f := firstPerson{
		name: "bob",
		age:  50,
	}

	var g struct {
		name string
		age  int
	}

	g = f
	fmt.Println(g == f)
}
```
---

## 블록, 섀도, 제어 구조

### 블록(block)

- 선언문이 있는 각각의 공간
- 관련 있는 문장을 묶은 것 (패키지 블록, 파일 블록, 함수 블록)
- 식별자의 스코프(scope)
  - 식별자의 Lifecycle(생명주기)
  - 블록 내에서 선언/정의될 때 식별자가 생성
  - 블록이 끝날 때 식별자가 제거
  - 블록 내에서만 해당 식별자 사용, 블록 밖에서는 해당 식별자 접근 X
- 패키지 블록
  - 함수 외부에 선언된 것
  - := 사용 불가
  - 대문자로 시작하는 식별자는 패키지 외부에 노출
  - 노출된 식별자는 점 연산자를 통해 접근
  - 소스 파일이 여러 개더라도 package 이름이 같으면 같은 패키지 블록 포함
- 파일 블록
  - .go 파일에 선언된 것
  - import문이 포함된 파일 
- 함수 블록
  - 로컬 변수 : 매개변수, 반환 변수도 포함 
  - 모든 중괄호는 새로운 블록 정의
  - 제어 구조도 자체의 블록
- 유니버스 블록
  - 기본 타입, 내장 함수, true/false와 같은 미리 선언된 식별자가 정의된 블록
  - 다른 모든 블록을 포함하는 블록
  - 다른 블록에 의해 섀도잉될 가능성 높음 
- 섀도잉(Shadowing)
  - 외부 블록과 내부 블록의 식별자가 같은 경우 `내부 블록의 식별자`로 처리
  - 내부 식별자에 의해 외부 식별자가 그림자에 가려 보이지 않음  
```go
package main

import "fmt"

func main() {
	x := 10
	if x > 5 {
		fmt.Println(x)
		x := 5
		fmt.Println(x)
	}
	fmt.Println(x)
}
```
- 출력 결과는 10, 5, 10 으로 출력
- := 연산자
  - 여러 변수를 := 연산자로 초기화 할때
  - 현재 블록에서 선언된 변수들만 재사용
- import된 패키지가 shadowing 되지 않도록 주의
  - import한 패키지 이름과 같은 식별자로 선언 X 

### if 문

- 조건을 괄호로 감쌀 순 있지만 감싸지 않음
- if 블록이나 else 블록내에서만 사용가능한 변수를 if 또는 else에서 바로 선언

### for 문

- for 문의 4가지 패턴
  1. C 언어와 동일한 방식의 for(완전한 구문)
      - 변수 초기화는 반드시 := 연산자 사용
      - for 내부에서 선언된 변수도 섀도잉 문제 발생 가능 
```go
package main

import "fmt"

func main() {
	for i := 0; i < 10; i++ {
		fmt.Println(i)
	}
}
```
  2. 조건식만 사용하는 for
      - 초기값과 증감식 생략
      - while과 비슷
```go
package main

import "fmt"

func main() {
	i := 1
	for i < 100 {
		fmt.Println(i)
		i = i * 2
	}
}
``` 
  3. for 문을 이용한 무한 루프
      - 조건식도 사용 X 
```go
package main

import "fmt"

func main() {
	for {
		fmt.Println("Hello")
	}
}
```
  4. break와 continue
     - 파이썬과 같은 개념
     - 코드를 간결하게 만들 수 있음 
```go
package main

import "fmt"

func main() {
	for i := 1; i <= 100; i++ {
		if i%3 == 0 && i%5 == 0 {
			fmt.Println("FizzBuzz")
			continue
		}
		if i%3 == 0 {
			fmt.Println("Buzz")
			continue
		}
		if i%5 == 0 {
			fmt.Println("Buzz")
			continue
		}
		fmt.Println(i)
	}
}
```
- for-range 문
  - 내장 타입의 요소(문자열, 배열, 슬라이스, 맵)을 순회하며 루프 수행
  - range가 두 개의 값을 반환 (index, value) 쌍
  - Go 에서는 반환되는 값을 사용할 의도나 필요가 없다면 _로 받음(=Python)
  - 키 값만 순회하는 대표적인 예
    - 맵 타입을 집합 타입으로 사용
    - 맵의 값보다는 유니크한 키 값이 중요 => 집합
  - 맵 순회
    - 요소를 처리하는 순서가 일정 X  (보안 이슈) 
  - 문자열 순회
    - 룬을 순회, byte 순회 아님
  - for-range 값은 복사본
- for 문 레이블링
  - 레이블 : 프로그램 코드 위치에 이름 붙인 것
  - break, continue, goto 문의 대상

### Switch 문

- switch, case, default, break
- 다른 언어의 switch
  - fall through 기능 존재
- Go는 fall-through가 기본적으로 금지, fall-through 키워드로 활성화 
- switch의 fallthrough
  - break 문을 만날 때 까지 다른 case의 내용도 실행

### 공백 Switch

- case에 불리언 결과(조건식, 불값을 반환하는 함수) 사용
- selector 없음

### goto 문

- Go에서 지원, 사용 X

---

## 함수

### 함수 선언과 호출

- 1급 객체(다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체)
- main 함수
  - 프로그램 진입점
  - 실행 파일을 만들려면 필요
  - 인자 X, 반환값 X
- 함수 선언 = 함수 헤더(시그니처) + 함수 몸체(바디)
  1. func 키워드
  2. 함수 이름
  3. 입력 파라미터 : 반드시 타입 명시 (Go는 정적 언어)
  4. 반환값의 타입 
  - => 함수의 시그니처
- return 키워드
- 여러 입력 파라미터가 같은 타입이라면 콤마로 파라미터를 구별하고 타입은 마지막에 기술
- Go는 키워드 파라미터(=named parameter) 지원 X  
- Go는 함수를 호출할 때 함수에서 정의한 파라미터 생략 X 
- 구조체를 사용하면 named parameter 및 선택적 parameter 방식 간접적 실현
- 가변 입력 파라미터와 슬라이스
  - 임의 개수의 입력 파라미터
  - 가변 파라미터는 반드시 함수의 입력 파라미터 목록에서 마지막 위치
  - 타입 이름 앞에 ...
  - 가변 파라미터는 함수 내에서는 해당 타입의 슬라이스
- 다중 반환값
  -  다중 반환값 허용, 쉼표로 구분하여 반환
  -  다중 반환값 받을 떄는 := 사용
- 반환되는 값 무시
  - 함수의 반환 값 개수와 받는 개수가 다르면 컴파일 에러
  - 일부만 무시하려면 _ 사용
  - 모든 반환값 무시 가능
- `이름이 지정된 반환값(naked return)`
  - 함수 정의 시 반환값 타입과 반환값 파라미터 선언
  - 해당 함수의 로컬 변수로 간주
  - 코너케이스
    - 섀도잉 문제 발생
- 빈 반환(blank return)
  - return 문에 반환값을 사용하지 않은 것
    - 반환값이 없는 함수
    - 이름 지정된 반환값을 반환하고자 할 때 return 생략하면 컴파일 에러

### 함수는 값

- 함수는 일급 객체
- 함수 타입 선언
  - Go는 강타입 정적 타입 언어
  - 함수를 저장하는 변수는 해당 함수의 타입으로 선언
  - 함수 타입: type 키워드로 정의
- 익명 함수
  - 이름 없는 함수 => 재사용 X
  - 변수에 저장할 용도가 아니므로 인라인으로 작성
  - 익명 함수를 호출해야하므로 함수 몸체 정의가 끝나고 괄호를 사용하여 인자를 넘겨줘야함 

### 클로저(Closure)

- 함수 내부에 선언된 함수 = 내부 함수(inner function)
- 외부 함수에 의해 반환되는 내부 함수, 내부함수는 외부 변수를 참조
- 파라미터로 함수를 전달

### defer

- 정리 작업을 수행하는 함수 지정
- 현재 코드 블록이 끝날 때 자동으로 실행
- defer는 여러번 사용 가능 -> LIFO으로 나중에 defer된 함수가 먼저 실행
- defer가 적용된 함수 중 반환값이 있는 함수의 반환값은 따로 읽을 방도가 없음
- defer와 이름 지정된 반환값

### 값에 의한 호출을 사용하는 Go

- Call by value : 인자나 반환값은 복사
- Call by reference : 주소가 복사
- 기본 타입, 구조체는 call by value
- 맵
  - 파라미터로 넘어온 맵에 대한 변경은 원본에도 적용
- 슬라이스
  - 길이 조정 외의 모든 조작이 원본에도 적용
- 맵과 슬라이스는 포인터로 구현 되었기 때문에 원본도 변경됨

---

## 포인터

### 포인터

- 값이 저장된 메모리의 위치 값(주소)를 저장하는 변수 
- 주소 연산자(&)
- 모든 포인터는 어떤 타입을 가리키던 항상 같은 크기
- 포인터의 제로 값은 nil
  - 슬라이스, 맵, 함수 의 제로값: nil
- nil은 숫자 0이 아님
  - nil을 숫자로 변경/변환하거나 숫자를 반대로 변환 X
- 포인터 dereferencing 전에 nil 인지 확인할 필요 있음
- 포인터 타입
  - 포인터가 가리키는 값의 타입
  - 포인터가 어떤 타입의 값을 가리키는지 나타냄
  - 포인터 변수를 선언할 때 주로 사용
  - 타입 이름 앞에 *
  - 포인터 역참조: 변수 이름 앞에 * 
- 내장 함수 new()
  - 포인터 변수 생성
  - 해당 타입의 제로 값을 가리키는 포인터 반환
- 기본 타입의 리터럴이나 상수는 주소가 없으므로 주소연산자 사용 불가
  - 헬퍼 함수를 사용하여 상수 값을 포인터로 변환

### 규칙

- 변수 선택
  - call by value vs call by reference
  - 함수에 변수를 그냥 넘기는 것
  - 함수에 변수의 포인터를 넘기는 것
- 포인터는 변경 가능한 파라미터 가리킴
  -  비 포인터 타입 : 기본타입, 배열, 구조체 => 원본의 불변성
  -  함수로 전달되면 포인터의 복사본 생성 => 원본 수정 가능

### 주의 사항

- 최후 수단으로 사용
  - 데이터 흐름 이해를 어렵게 함
  - GC(가비지 컬렉터)에게 추가 작업 부하를 검 => 주로 힙을 이용
  - 가비지는 힙에 생성
- 포인터로 성능 개선
  - 포인터는 모든 데이터 타입을 함수로 전달할 때 상수 시간 걸림
    - 주소를 함수에 전달하므로 모든 데이터 타입의 주소 길이는 같음 
  - 대략 1메가 바이트 전달 기준
    - 이상이면 포인터로 전달
    - 이하면 값 전달
- 제로 값과 값없음의 차이
  - 0, ' ' vs NULL , '' => nil
- 포인터를 이용하여 변수나 구조체의 항목의 값이 제로값인지 구분
- 할당되지 않은 변수나 구조체 항목에 nil 포인터 사용
- 포인터는 변경가능 , 함수에서 nil 포인터를 직접 반환하는 것보다 콤마 OK 관용구 사용
- nil 포인터를 함수의 파라미터나 구조체의 항목의 값으로 담음
  - 함수의 인자로 넘기면 nil 포인터를 통해서 값 저장 X
  - 함수 안에서 값을 설정 X 

### 버퍼 슬라이스

- 메모리 용도에 따른 구분
  - 버퍼(buffer) : 한 곳에서 다른 곳으로 데이터를 이동할 때 임시적으로 그 데이터를 저장하기 위해 사용되는 물리적인 메모리 저장소
  - 캐시(cache) : 데이터나 값을 미리 복사해 놓는 임시 저장소
  - 풀(pool) : 데이터를 사용할 수 있도록 미리 준비가 되어있는 메모리 저장소

### 가비지 컬렉션 작업량 줄이기

- 버퍼를 이용하면 GC의 부하를 줄일 수 있음
- 가비지(Garbage)
  - 더 이상 어떤 포인터도 가리키지 않는 데이터

---

## 타입, 메서드, 인터페이스

### Go의 타입

- 내장 타입
  - 기본 타입, 복합 타입
- 구조체를 이용한 사용자 정의 타입
- 구체적인 타입(Concrete type)
  - abstract type = general, super, incomplete, 미완성(상속)
  - <-> concrete = specific, sub, 완성(상속)

### 메서드

- 타입을 위한 메서드
  - 반드시 패키지 블록 레벨에서 정의
- 리시버
  - func 키워드와 메서드 이름 사이에 리시버_이름 타입을 괄호로 정의
  - 리시버 식별자는 관례적으로 타입 이름의 짧은 약어인 첫 문자를 사용

### 포인터 리시버와 값 리시버

- 포인터 리시버 : 리시버 타입 앞에 *을 붙임
- 규칙
  - 메서드가 리시버를 수정 -> 포인터 리시버 사용
  - 메서드가 nil 인스턴스를 처리할 필요 -> 포인터 리시버 사용
  - 메서드가 리시버를 수정 X -> 값 리시버 사용 가능
    - 이것은 타입에 선언된 다른 메서드에 따라 결정
    - 같은 타입에 다른 리시버가 포인터 리시버라면 리시버를 수정하지 않는 메서드라도 포인터 리시버 사용 (일관성)

### nil 인스턴스를 위한 메서드

- 포인터 메서드 사용
- nil 인스턴스, 제로 값이 nil
  - 슬라이스
  - 맵
  - 포인터

### 메서드도 함수

- 메서드를 변수에 할당하거나 함수의 입력으로 반환값 사용 가능
  - => 메서드 값(method value)
- 메서드 표현식 : 타입 자체로 함수 생성
- 메서드 표현식을 이용하여 메서드를 호출할 때는 첫 번째 인자로 메서드 리시버 사용

### 타입 특징

- 타입 선언은 상속 X
- 다른 타입 기반으로 타입 선언
  - 상속 X
  - 계층이라는 개념 X
  - 타입들은 동등한 레벨
- 기본 타입이 내장 타입인 사용자 정의 타입의 경우 해당 기본 타입의 연산자와 함께 사용
- 기본 타입과 호환되는 리터럴 및 상수 대입
- 타입은 실행가능한 문서 
  - 사용자 타입을 선언하는 시점
    1. 구조체의 경우 우리가 필요한 시점
    2. 기존 타입을 기반으로 사용자 정의 타입을 선언하는 것
      - 개념을 위한 이름을 타입 이름으로 지정하여 코드를 명확하게 하고 기대되는 데이터의 종류를 기술할 목적
- 열거형을 위한 iota
  - 열거형(enumeration, enum)
    - 카테고리성 데이터, 명목형 데이터
  - 열거형 만들기
    1. 모든 유효한 값을 나타내는 `정수` 기반의 타입 정의
    2. 값의 집합을 만들기 위해 const 블록 사용
    3. const 블록에서 첫 번째 상수에 iota 지정  

### 임베딩

- composition over inheritance -> 클래스 상속보다는 객체 구성 선호
- 어떤 타입이든 구조체로 임베딩 가능

### 인터페이스

- 암묵적 인터페이스 : Go의 유일한 추상 타입
- 인터페이스의 목적/용도
  - 스펙 정의
  - 인터페이스의 요소를 완성/구현(implement)해야 함
- 인터페이스 리터럴
  - 인터페이스 타입 이름 뒤에 작성
  - 리터럴에는 인터페이스를 만족시키기 위한 구체적 타입에서 반드시 구현해야할 메서드 시그니처 나열
- 관례적으로 인터페이스 이름은 끝에 'er'을 붙임
- 인터페이스는 모든 블록에서 선언 가능
- 구조체 반환하기
  - 인터페이스를 받고 구조체 반환
  - 함수로 실행되는 비즈니스 로직은 인터페이스를 통해 실행
  - 함수의 출력은 구체적 타입

### 타입 단언 및 타입 스위치

- 인터페이스 변수에 할당된 구체적 타입 확인
- 구체적 타입이 다른 인터페이스를 구현했는지 확인
- 타입 단언(Type Assertion)
  - 인터페이스 변수(타입)
- 타입 스위치 
  - 인터 페이스 + switch 문 

---

## Go의 동시성

### 동시성 사용 시점

- 동시성은 병렬성 X
  - 동시성 코드가 병렬적으로 실행되는지는 하드웨어와 알고리즘
  - 동시성은 동시에 실행되는 것이 시간이 얼마 걸리지 않을 때 사용하는 것은 좋지 않음
  - 동시성은 공짜 X

### 고루틴

- 프로세스
- 쓰레드
- OS의 스케줄러 및 Go 런타임 스케줄러
- Go 런타임 스케줄러 이점
  - 고루틴 생성은 스레드 생성보다 빠름
  - 고루틴은 메모리를 더 효율적으로 사용
  - 고루틴 간의 전환은 스레드 사이의 전환보다 빠름
  - 스케줄러는 Go 프로세스의 일부이기 때문에 스케줄링 결정을 최적화
- Go 키워드
  - Go 런타임에서 관리하는 가벼운 프로세스
  - 비즈니스 로직을 구현한 클로저를 고루틴으로 실행하는 것이 관례 

### 채널

- 고루틴은 채널을 통해 통신
- make 함수로 생성
- 내장 타입
- 채널의 제로 값은 슬라이스, 맵, 포인터 처럼 nil
- ← 연산자를 사용하여 채널과 상호작용
- 채널에 쓰여진 각 값은 한 번에 하나씩 읽을 수 있음